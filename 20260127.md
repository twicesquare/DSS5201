# 20250127
## 宽幅数据，没有重复，但可能有很多缺失值
适合简单运算
## 长数据，通常被视为clean的标准
长/宽数据的不同（说实话没怎么看懂）<br><br>
![](https://cdn.jsdelivr.net/gh/twicesquare/pics@main/20260127134857739.png)
疑似长数据->宽数据的转换
![](https://cdn.jsdelivr.net/gh/twicesquare/pics@main/20260127135210772.png)
## reshaping using pivot method pivot法
### df.pivot(index = "A", columns = "B", values = "C")
A: 哪一列作为索引  
B: 哪一列作为列名  
C: 哪一列作为填充/数值  

### Drop the fifth row
```
# axis=0 表示操作对象是“行”
fifa_no_rep = fifa_players.drop(4, axis=0)

# 或者如果你想根据位置删除，更稳妥的做法是使用索引名
# fifa_no_rep = fifa_players.drop(fifa_players.index[4])
```
在使用**df.pivot(index = "A", columns = "B")** 不含value时，需要确认没有重复值，不然会出错

## using Pivot tables 数据透视表法
### df.pivot_table(index = "A", columns = "B", values = "C", aggfunc = "D")
1. pivot_table可以避免pivot因为重复值而出错的问题，关键在于aggfunc，比如取"mean"就是平均值（如果没有两个值，那就是原值）
2. pivot_table可以拥有多层索引
3. `margins="True"`时，即默认添加所有行和列（添加总结）

### `discard(i)`, discard是集合的方法，不适用于df
`remove(x)`：如果元素 x 不在集合里，它会报错（抛出 KeyError）。

`discard(x)`：如果元素 x 不在集合里，它会保持沉默（什么都不做，也不报错）。
### `drop(i, axis=0)`
为了避免记混 axis=0（行）和 axis=1（列），现在的 Pandas 推荐使用语义化参数，这样就不需要写 axis 了:   

删除行：`df.drop(index=[1, 2])`  
删除列：`df.drop(columns=["col_A"])`

## melt重塑，宽数据->长数据
### `df.melt(id_vars="你想当作index的列")`
![](https://cdn.jsdelivr.net/gh/twicesquare/pics@main/20260127154145983.png)
| 参数 | 逻辑角色 | 形象理解 |
| :--- | :--- | :--- |
| id_vars | 保持不变的列 | 标识符（如：姓名、ID），它们会重复出现 |
| value_vars | 需要被“融化”的列 | 你想从“横着排”变成“竖着排”的那些数据列 |
| var_name | 新列的名字（原列名） | 比如把“2020”、“2021”统称为“年份” |
| value_name | 新列的名字（原数值） | 比如把具体的销售额数值统称为“销售额” |

## Wide to long function
![](https://cdn.jsdelivr.net/gh/twicesquare/pics@main/20260127155053538.png)
<br><br>
这样设置的wide_to_long不会保留原来的index，如果需要保留，则需要在i上加上原来的index
### sep设置分隔符，分隔符相当于跳过这个元素
![](https://cdn.jsdelivr.net/gh/twicesquare/pics@main/20260127155416630.png)
### suffix设置后缀为单词，而非数字
![](https://cdn.jsdelivr.net/gh/twicesquare/pics@main/20260127155535910.png)
<br><br>
pandas默认单词+数字的模式，如果是单词+单词则需要额外设置suffix为`\w+`

## `reset_index(drop=False, inplace=True)`
`drop=False` 是默认值，表示保留原索引作为列  
`inplace=True` 表示直接在原对象上修改，不产生新副本

## 含有string字符串列的重塑
### 使用str.split的方法
![](https://cdn.jsdelivr.net/gh/twicesquare/pics@main/20260127162346590.png)
如果没有`expand=True`，则是一个完整的列表，需要使用`str.get(0)`
![](https://cdn.jsdelivr.net/gh/twicesquare/pics@main/20260127161136515.png)
`expand = True`代表把split之后的分为两列
![](https://cdn.jsdelivr.net/gh/twicesquare/pics@main/20260127161237420.png)
记得删除原来的列
![](https://cdn.jsdelivr.net/gh/twicesquare/pics@main/20260127161803015.png)
### 使用split.cat，链接两列
![](https://cdn.jsdelivr.net/gh/twicesquare/pics@main/20260127161352425.png)
![](https://cdn.jsdelivr.net/gh/twicesquare/pics@main/20260127161509511.png)
直接把链接好的列作为新列
![](https://cdn.jsdelivr.net/gh/twicesquare/pics@main/20260127161633673.png)
把index和后面某一列连接起来作为新的index
![](https://cdn.jsdelivr.net/gh/twicesquare/pics@main/20260127161902220.png)
自己创建新list，并与已有list链接起来

# 20260125

## explicit indexes
### 设置index
```
# 1. 修正：使用 .set_index("city")
temperatures_ind = temperatures.set_index("city")

# Look at temperatures_ind
print(temperatures_ind.head())

# 2. 修正：使用 .reset_index()，保持内容（city 会变回普通列）
print(temperatures_ind.reset_index())

# 3. 修正：使用 .reset_index(drop=True)，丢弃内容（city 索引被直接删掉）
print(temperatures_ind.reset_index(drop=True))
```

### 使用index定位
```
# Subset temperatures using square brackets
print(temperatures[temperatures["city"].isin(cities)])

# Subset temperatures_ind using .loc[]
print(temperatures_ind.loc[cities])
```
### Setting multi-level indexes
```
# Index temperatures by country & city
temperatures_ind = temperatures.set_index(["country", "city"])

# 修正：将内部的方括号 [] 改为圆括号 ()
# 这是一个元组列表 (List of Tuples)
rows_to_keep = [("Brazil", "Rio De Janeiro"), ("Pakistan", "Lahore")]

# Subset for rows to keep
print(temperatures_ind.loc[rows_to_keep])
```
#### 深度解析：为什么用元组？
**列表 []：** 在 Pandas 索引操作中，外层的列表表示“我要选多个元素”。

**元组 ()：** 表示“这是一个完整的多级标签”。
("Brazil", "Rio De Janeiro") 告诉 Pandas：去第一级索引找 Brazil，同时在第二级索引找 Rio De Janeiro。

#### 排序索引
当你对 DataFrame 设置了多级索引后，强烈建议紧接着运行一次 `.sort_index()`。这不仅能让显示更整齐，还能显著提升 .loc 的查询速度  

区别于对于普通列的`sort_values()`

### Sorting by index values
```
# 3. 修正：使用 level 指定层级，ascending 传入列表
# [True, False] 表示：第一个索引(country)升序，第二个索引(city)降序
print(temperatures_ind.sort_index(level=["country", "city"], ascending=[True, False]))
```
`level` 用于指定多级索引中的哪一层。

## Slicing and subsetting with .loc and .iloc
```
# Sort the index of temperatures_ind
temperatures_srt = temperatures_ind.sort_index()

# Subset rows from Pakistan to Philippines
print(temperatures_ind.loc["Pakistan":"Philippines"])

# Try to subset rows from Lahore to Manila
print(temperatures_ind.loc[("Lahore"):("Manila")])

# Subset rows from Pakistan, Lahore to Philippines, Manila
print(temperatures_ind.loc[("Pakistan","Lahore"): ("Philippines","Manila")])
```

### loc对于行和列的用法
```
# Subset rows from India, Hyderabad to Iraq, Baghdad
print(temperatures_srt.loc[("India","Hyderabad"):("Iraq","Baghdad")])

# Subset columns from date to avg_temp_c
#语法：loc[行, 起始列:结束列]
print(temperatures_srt.loc[:, "date":"avg_temp_c"])

# Subset in both directions at once
# !!!注意这个，是行和列同时切片的方式，同时含有双层index
print(temperatures_srt.loc[("India","Hyderabad"):("Iraq","Baghdad"),"date":"avg_temp_c"])
```

#### 总结
| 需求 | 正确语法 | 注意点 |
| :--- | :--- | :--- |
| 仅行切片 | df.loc[start_row : end_row] | 包含末尾 |
| 仅列切片 | df.loc[:, start_col : end_col] | 必须加前面的冒号和逗号 |
| 特定列列表 | df.loc[:, ["col_A", "col_B"]] | 选特定几列用 [] |
| 列范围切片 | df.loc[:, "col_A" : "col_C"] | 不能用 [] |
| 双向切片 | df.loc[行切片, 列切片] | 逗号是行与列的分界线 |

### 时间的loc
```
# 1. 使用布尔条件筛选（注意引号和列引用）
# 假设 date 列已经是日期类型，可以直接比较字符串
temperatures_bool = temperatures[(temperatures["date"] >= "2010-01-01") & (temperatures["date"] <= "2011-12-31")]
print(temperatures_bool)

# 2. 设置索引并排序（注意 "date" 加引号）
temperatures_ind = temperatures.set_index("date").sort_index()

# 3. 使用 .loc 进行年份切片（非常简洁！）
# 当索引是日期且已排序时，可以直接传入年份字符串
print(temperatures_ind.loc["2010":"2011"])

# 4. 使用 .loc 进行月份范围切片（注意引号，防止变成减法）
print(temperatures_ind.loc["2010-08":"2011-02"])
```

### iloc的切片用法
```
# Get 23rd row, 2nd column (index 22, 1)
print(temperatures.iloc[22,1])

# Use slicing to get the first 5 rows
print(temperatures.iloc[0:5])

# Use slicing to get columns 3 to 4
print(temperatures.iloc[:,2:4])

# Use slicing in both directions at once
print(temperatures.iloc[0:5, 2:4])
```

## slicing和pivot的结合
### 如何从时间中单拎一个年/月出来
You can access the components of a date (year, month and day) using code of the form `dataframe["column"].dt.component`. 
For example, the month component is `dataframe["column"].dt.month`, and the year component is `dataframe["column"].dt.year`.
```
# Add a year column to temperatures
temperatures["year"] = temperatures["date"].dt.year

# Pivot avg_temp_c by country and city vs year
temp_by_country_city_vs_year = temperatures.pivot_table(values="avg_temp_c", index=("country","city"), columns = "year")

# See the result
print(temp_by_country_city_vs_year)
```
### Calculating on a pivot table
`mean()` 方法可以通过 axis 参数指定是按行计算还是按列计算

`axis="index"`  
`axis="columns"`

使用方括号内的逻辑条件，对 Series 或 DataFrame 进行子集化，以查找感兴趣的行。

`series[series > value]`

## Visualizing your data
### 柱状图，kind="bar"，以及groupby的回忆
```
# Import matplotlib.pyplot with alias plt
import matplotlib.pyplot as plt

# Look at the first few rows of data
print(avocados.head())

# Get the total number of avocados sold of each size
nb_sold_by_size = avocados.groupby("size")["nb_sold"].sum()

# Create a bar plot of the number of avocados sold by size
nb_sold_by_size.plot(kind="bar")

# Show the plot
plt.show()
```

### 线型图
#### groupby之后的数据格式
```
nb_sold_by_date = avocados.groupby("date")["nb_sold"].sum()

print(nb_sold_by_date.head())
```
```
    date
    2015-01-04    27279606.03
    2015-01-11    25081927.33
    2015-01-18    24961540.48
    2015-01-25    24094678.66
    2015-02-01    39838734.08
    Name: nb_sold, dtype: float64
```
### 散点图
```
avocados.plot(
    kind = "scatter", 
    x = "nb_sold", 
    y = "avg_price", 
    title = "Number of avocados sold vs. average price")
```
注意，x和y就是x和y，没有axis

### legend图例
```
# Histogram of conventional avg_price 
avocados[avocados["type"] == "conventional"]["avg_price"].hist()

print(avocados[avocados["type"] == "conventional"]["avg_price"])

# Histogram of organic avg_price
avocados[avocados["type"] == "organic"]["avg_price"].hist()

# Add a legend
plt.legend(["conventional" ,"organic"])
```
**1. L - 筛选定位 (Locate / Filter)**

    语法：df[df["column"] == "value"]  
    逻辑内核：横向切割（行过滤）。

**2. S - 属性聚焦 (Select / Extract)**

    语法：df["target_column"]  
    逻辑内核：纵向切割（列提取）。

### 透明度alpha的设置
```
# Modify histogram transparency to 0.5 
avocados[avocados["type"] == "conventional"]["avg_price"].hist(alpha = 0.5)
```

### bins的设置
```
# Modify bins to 20
avocados[avocados["type"] == "conventional"]["avg_price"].hist(alpha=0.5, bins = 20)
```
分成 20 个区间（桶）,默认为10个桶

## 缺失值处理
`isna()`，是否有缺失值，每一个值单独判断

`isna().any()`，每一行是否有缺失值，总的判断

`isna().sum()`，每一行缺失值汇总

`avocados_2016.isna().sum().plot(kind = "bar")`

`dropna()`，丢弃缺失值的行

`fillna(0)`，0填充

## 创建DF
### list-of-dict
外面是[]，里面是多个{"A":1,"B":"2"...}字典，每个字典是一行
### dict-of-list
外面是{}，里面是每列按顺序的列表,D,"2","3"]

`pd.DataFrame(dict-of-list)`

## 读写CSV文件
读CSV  
`pd.read_csv("名字")`

df转CSV  
`df.to_csv("名字")`

### 总体的一个例子
```
airline_bumping = pd.read_csv("airline_bumping.csv")
print(airline_bumping.head())
airline_totals = airline_bumping.groupby("airline")[["nb_bumped", "total_passengers"]].sum()
airline_totals["bumps_per_10k"] = airline_totals["nb_bumped"] / airline_totals["total_passengers"] * 10000
print(airline_totals)
```
### sort_values中按某一列排序用的是`by="列A"`
```
# Create airline_totals_sorted
airline_totals_sorted = airline_totals.sort_values(by = "bumps_per_10k", ascending = False)

# Print airline_totals_sorted
print(airline_totals_sorted)

# Save as airline_totals_sorted.csv
airline_totals_sorted.to_csv("airline_totals_sorted.csv")
```

## Wrap up

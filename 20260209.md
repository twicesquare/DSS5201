# 20260209

## filter join

### semi-join的定义
![](https://cdn.jsdelivr.net/gh/twicesquare/pics@main/20260209145210258.png)

### anti join
是semi join的反过来

## 垂直链接两个表 vertically
`concat`，自动垂直链接

## 验证数据的完整性
`merge`中的`validate='one_to_one'`或者1-N，或者N-N OR N-1，一旦不满足这个条件，则直接error

`concat`中的`validate_integrity = True / False`, 只检查索引index是否重复，不检查具体列

## `merge_ordered()`，排列时间序列/其他
**默认join type是outer**

`pd.merge_ordered(df1,df2)`，就算后面有其他参数好像也不需要加中括号

`fill_method='ffill'`，填充空白值的方法，ffill是向前填充

## `merge_asof()`
匹配的是最近的值列，即比如1-1，5-4，8-7。。。（差值最小）

`direction = forward / backward(默认) / nearest`控制是左>右还是右>左，不写就是backward

必须排列

最终结果类似于left-join

![](https://cdn.jsdelivr.net/gh/twicesquare/pics@main/20260209185356399.png)

### 模糊匹配 fuzzy matching
数值或时间轴上的“就近匹配”

## `.query()`
记得()里面就要先加一层''

条件语句再另外用""包裹

## 练习代码
### 练习1
```
# Concatenate the tables and add keys
inv_jul_thr_sep = pd.concat((inv_jul, inv_aug, inv_sep), 
                            keys=('7Jul', '8Aug', '9Sep'))

# Group the invoices by the index keys and find avg of the total column
avg_inv_by_month = inv_jul_thr_sep.groupby(level=0).agg({'total':'mean'})

# Bar plot of avg_inv_by_month
avg_inv_by_month.plot(kind='bar')
plt.show()
```

### 练习2
```
# Merge gdp and pop on date and country with fill and notice rows 2 and 3
ctry_date = pd.merge_ordered(gdp, pop, on=['date', 'country'],
                             fill_method='ffill')
```
学糊涂了，merge_ordered的on用法，没有left_on或者right_on

### 练习3
```
# Use merge_asof() to merge jpm and wells
jpm_wells = pd.merge_asof(jpm, wells, on='date_time',suffixes=('', '_wells'), direction='nearest')


# Use merge_asof() to merge jpm_wells and bac
jpm_wells_bac = pd.merge_asof(jpm_wells, bac, on='date_time',suffixes=('_jpm', '_bac'), direction='nearest' )

# Compute price diff
price_diffs = jpm_wells_bac.diff()

# Plot the price diff of the close of jpm, wells and bac only
price_diffs.plot(x='date_time', y=['close_jpm', 'close_wells', 'close_bac'])
plt.show()
```
`diff()`计算的是每两列的差值

注意plot的用法

```
# Merge gdp and recession on date using merge_asof()
gdp_recession = pd.merge_asof(gdp, recession, on='date')

# Create a list based on the row value of gdp_recession['econ_status']
is_recession = ['r' if s=='recession' else 'g' for s in gdp_recession['econ_status']]

# Plot a bar chart of gdp_recession
gdp_recession.plot(kind='bar', y='gdp', x='date', color=is_recession, rot=90)
plt.show()
```

### 练习4
```
# Merge gdp and pop on date and country with fill
gdp_pop = pd.merge_ordered(gdp, pop, on=['country','date'], fill_method='ffill')

# Add a column named gdp_per_capita to gdp_pop that divides the gdp by pop
gdp_pop['gdp_per_capita'] = gdp_pop['gdp'] / gdp_pop['pop']

# Pivot data so gdp_per_capita, where index is date and columns is country
gdp_pivot = gdp_pop.pivot_table('gdp_per_capita', 'date', 'country')

# Select dates equal to or greater than 1991-01-01
recent_gdp_pop = gdp_pivot.query('date >= "1991-01-01"')

# Plot recent_gdp_pop
recent_gdp_pop.plot(rot=90)
plt.show()
```
久违的pivot_table

### 练习5 melt
melt是pivot的反方向方法
pivot是把长数据->短数据
melt是短->长
![](https://cdn.jsdelivr.net/gh/twicesquare/pics@main/20260209191657237.png)

`sort(by='date', ascending=True)`

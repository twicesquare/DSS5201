### for的用法_enumerate
![](https://cdn.jsdelivr.net/gh/twicesquare/pics@main/20260120174303451.png)
enumerate可以给for循环中的变量添加index

### for中的字典用法
![](https://cdn.jsdelivr.net/gh/twicesquare/pics@main/20260120175518877.png)
两个变量的名字可以随便取，只要第一个是键，第二个是值

字典是无序的, my_dict.item()&nbsp;&nbsp;**my_dict是我的字典的名字，不是用法**

### for中numpy数组的循环
![](https://cdn.jsdelivr.net/gh/twicesquare/pics@main/20260120175803536.png)

如果如图所示为一个二维数组，则需np.nditer()，保险起见可以任何时候都用

**如果你用传统的 for 循环遍历一个 3 维数组，你需要写三层嵌套循环。而 np.nditer() 可以让你用一层循环就遍历完所有元素，无论数组是多少维。**
```
import numpy as np
arr = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])

# 无论多少维，直接一个循环搞定
for x in np.nditer(arr):
    print(x, end=' ')
# 输出: 1 2 3 4 5 6 7 8
```
**普通的 for 循环遍历数组时，拿到的是元素的副本，修改它不会影响原数组。使用 np.nditer 并设置 op_flags=['readwrite'] 可以原地修改数组内容。**
```
# 将数组中的每个元素翻倍
for x in np.nditer(arr, op_flags=['readwrite']):
    x[...] = 2 * x
```
**一句话建议： 只要能用 a + b 这种方式解决的，就不要用循环；如果非要写循环处理多维数据，np.nditer() 是比嵌套 for 循环更专业、更强大的工具。**

### for中csv文件的循环
```
# Import cars data
import pandas as pd
cars = pd.read_csv('cars.csv', index_col = 0)

# Iterate over rows of cars
for l, r in cars.iterrows():
    print(l)
    print(r)
```
基础用法
```
for lab, row in brics.iterrows() :
    print(row['country'])
```
具体打印某一列的内容
```
# Adapt for loop
for lab, row in cars.iterrows() :
    print(str(lab) + ": " + str(row['cars_per_cap']))
```
```
# Code for loop that adds COUNTRY column
for lab, row in cars.iterrows() :
    cars.loc[lab, "COUNTRY"] = row["country"].upper()
```
使用loc循环的添加一个新列，以及upper的用法
```
# apply 会把函数应用在 "country" 列的每一个元素上
for lab, row in cars.iterrows() :
    cars["COUNTRY"] = cars["country"].apply(str.upper)
```
使用upper的apply方法，upper() is a method,所以用法需要调整
```
brics["name_length"] = brics["country"].apply(len)
```
使用len的apply用法

### random伪随机数
![](https://cdn.jsdelivr.net/gh/twicesquare/pics@main/20260120182746070.png)
`np.random.randint(0,2) #随机生成0或1`  
`print(np.random.randint(1,7))`&nbsp;&nbsp;randint就是直接选数了，等同于rand

### 随即数怎么转化成前进步数
```
# NumPy is imported, seed is set

# Initialize random_walk
random_walk = [0]

# Complete the ___
for x in range(100) :
    # Set step: last element in random_walk
    step = random_walk[-1]

    # Roll the dice
    dice = np.random.randint(1,7)

    # Determine next step
    if dice <= 2:
        step = step - 1
    elif dice <= 5:
        step = step + 1
    else:
        step = step + np.random.randint(1,7)

    # append next_step to random_walk
    random_walk.append(step)

# Print random_walk
print(random_walk)
```
max约束
```
if dice <= 2:
        # Replace below: use max to make sure step can't go below 0
        step = step - 1
        step = max(0, step) #添加约束条件，步数不可能为负
```
图示化步数
```
# Import matplotlib.pyplot as plt
import matplotlib.pyplot as plt

# Plot random_walk
plt.plot(random_walk)

# Show the plot
plt.show()
```
两层嵌套循环
```
# Initialize all_walks (don't change this line)
all_walks = []

# Simulate random walk five times
for i in range(5) :

    # Code from before
    random_walk = [0]
    for x in range(100) :
        step = random_walk[-1]
        dice = np.random.randint(1,7)

        if dice <= 2:
            step = max(0, step - 1)
        elif dice <= 5:
            step = step + 1
        else:
            step = step + np.random.randint(1,7)
        random_walk.append(step)

    # Append random_walk to all_walks
    all_walks.append(random_walk[-1])

# Print all_walks
print(all_walks)
```

### random walk
```
# numpy and matplotlib imported, seed set.

# initialize and populate all_walks
all_walks = []
for i in range(5) :
    random_walk = [0]
    for x in range(100) :
        step = random_walk[-1]
        dice = np.random.randint(1,7)
        if dice <= 2:
            step = max(0, step - 1)
        elif dice <= 5:
            step = step + 1
        else:
            step = step + np.random.randint(1,7)
        random_walk.append(step)
    all_walks.append(random_walk) # all_walks（一个“列表的列表”）

# Convert all_walks to NumPy array: np_aw
np_aw = np.array(all_walks) # np_aw 的形状（Shape）是 (5, 101)，即 5 行（次数），101 列（每步的位置）

# Plot np_aw and show
plt.plot(np_aw)
plt.show()

# Clear the figure
plt.clf()

# Transpose np_aw: np_aw_t
np_aw_t = np.transpose(np_aw)
# np.transpose() 将矩阵旋转了 90 度（转置），形状变成了 (101, 5)

# Plot np_aw_t and show
plt.plot(np_aw_t) # 横轴是步数（0-100），纵轴是到达的高度。现在的列：每一列代表一个完整的随机漫步过程（101 个点）。
plt.show()
```
转置后选取500次的最后一行（最终步数）
```
# Select last row from np_aw_t: ends
# 修正：使用 [-1, :] 或直接 [-1] 来选取最后一行
# 这一行代表了 500 次随机漫步最终到达的高度
ends = np_aw_t[-1, :]
```
假设你模拟了 500 次 随机漫步，每场漫步走了 100 步：

原始的 np_aw 形状是 (500, 101)。

转置后的 np_aw_t 形状是 (101, 500)。

这意味着：

101 行：对应第 0 步、第 1 步...一直到第 100 步。

500 列：每一列都是一个完整的、独立的随机漫步路径。

ends = np_aw_t[-1] 时，你其实是切下了矩阵的 最后一行。

```
In [3]:
np.sum(ends >= 60) / 500
Out[3]:
np.float64(0.784)
```
简单的sum法求出>=60的次数
